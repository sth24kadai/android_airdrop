// #region Imports
import React, { Component } from 'react'
import {
	Platform,
	StyleSheet,
	TouchableOpacity,
	Text,
	FlatList,
	RefreshControl,
	View,
} from 'react-native'
import { SafeAreaProvider } from 'react-native-safe-area-context';
import SafeAreaView from 'react-native-safe-area-view';
import { Icon, ListItem } from 'react-native-elements'
import Zeroconf, { Service } from 'react-native-zeroconf'
import { BridgeServer } from 'react-native-http-bridge-refurbished';
import { 
	ActivityIndicator, 
	Button as PaperButton 
} from 'react-native-paper';
import DeviceInfo from 'react-native-device-info';

import { Buffer } from 'buffer';

import { Ask } from '../types/airdrop.ask';
import { Discover } from '../types/airdrop.discover';
import { HTTPImageFrom, HTTPImageRequest } from '../types';
import { Context } from '../components/context';
//@ts-ignore

// #endregion
// #region Zeroconf Class Definition

const zeroconf = new Zeroconf()

// #endregion

import { NativeStackScreenProps } from "react-native-screens/lib/typescript/native-stack/types";
type RootStackParamList = {
    „Éá„Éê„Ç§„Çπ„ÅÆÈÅ∏Êäû: undefined;
    DetailScreen: undefined;
    LogScreen: undefined;
};

/**
 * „Ç¢„Éó„É™„ÅÆ„Ç®„É≥„Éà„É™„Éº„Éù„Ç§„É≥„Éà
 */
export default class App extends Component<NativeStackScreenProps<RootStackParamList, '„Éá„Éê„Ç§„Çπ„ÅÆÈÅ∏Êäû'>> {
    static contextType = Context;
    //@ts-ignore
    context!: React.ContextType<typeof Context>
	/**
	 * Zeroconf„ÅÆ„Ç§„É≥„Çø„Éº„Éê„É´„Éè„É≥„Éâ„É©Â§âÊï∞	
	 */
	public timeout: NodeJS.Timeout | undefined = void 0

	/**
	 * ‰ΩøÁî®„Åô„Çã„Éù„Éº„Éà
	 */
	public AIRDROP_HTTP_PORT = 8771

	/**
	 * HTTP„Çµ„Éº„Éê„Éº„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ
	 */
	private __BridgeServer: BridgeServer | null = null

// #region HTTP Client Server
	/**
	 * HTTP„Çµ„Éº„Éê„Éº„ÇíËµ∑Âãï„Åó„Åæ„Åô„ÄÇ
	 * 
	 * @returns 
	 */
	public httpServer() {
		const httpbridge = new BridgeServer("neardrop.local", true)
		httpbridge.listen(this.AIRDROP_HTTP_PORT);

		this.context.logs.push({
			emoji: 'üîó',
			message: `Starting HTTP server on port ${this.AIRDROP_HTTP_PORT}`
		})

		httpbridge.get('/info', async ( request, response ) => {
			return ({
				status : "OK",
				data : {
					clientId : DeviceInfo.getUniqueId(),
					clientName : DeviceInfo.getModel(),
					clientModel : Platform.OS
				}
			})
		})

		httpbridge.get('/authorization', async ( request , response ) => {
			
		})

		httpbridge.post("/Discover", async (request, response) => {
			return {
				"ReceiverMediaCapabilities": Buffer.from(JSON.stringify({
					version: 1
				})),
				"ReciverComputerName": "Google Pixel 6a",
				"ReceiverModelName": "Pixel 6a",
			} as Discover
		})

		httpbridge.post<Ask>("/Ask", async (request, response) => {

			const data = request.data
			this.context.senderData = data as Ask

			return {
				"ReceiverComputerName": "Google Pixel 6a",
				"ReceiverModelName": "Pixel 6a"
			} as Ask
		})

		httpbridge.post<string>("/upload", async ( request, response ) => {
			const postJSONData = JSON.parse( JSON.stringify( request.data ) ) as HTTPImageRequest
			console.log( postJSONData.status ) 

			const deviceInfomationfromHash = JSON.parse(
				Buffer.from( postJSONData.from, "base64" ).toString("utf-8")
			) as HTTPImageFrom

			const data = Buffer.from( postJSONData.image )
			this.context.logs.push({
				emoji : "‚ö†Ô∏è",
				message : `Received ${data.byteLength} bytes of data from ${deviceInfomationfromHash.name}(${deviceInfomationfromHash.id})`
			})
			this.context.logs.push({
				emoji: 'üì®',
				message: `Received ${data.byteLength} bytes of data`
			})

			this.context.notification = {
				emoji: 'üì®',
				message: `Received ${data.byteLength} bytes of data`
			}

			this.context.recivedDatas.push({
				from: postJSONData.from,
				bytes: data.byteLength,
				data: data
			})

			return {
				"status": "OK"
			}
		})

		return httpbridge;
	}

//#endregion

// #region Static Functions
	/**
	 * „Éá„Éê„Ç§„Çπ„ÅÆÁ®ÆÈ°û„ÇíÂèñÂæó„Åó„Åæ„Åô„ÄÇ
	 * ‰æùÂ≠ò„Åó„Å™„ÅÑstatic„Å™Èñ¢Êï∞
	 */
	static get deviceType() : number {
		const device = Platform.OS;
		switch( device ) {
			case "android" : return 1;
			case "ios" : return 1;
			case "macos" : return 3;
			case "windows" : return 3;
			case "web" : return 0;
			default: return 0;
		}
	}

	/**
	 * TXT„É¨„Ç≥„Éº„Éâ„ÅÆÂÄ§„ÇíÁîüÊàê„Åó„Åæ„Åô„ÄÇ 
	 */
	static TXTRecodeValue() : Uint8Array {
		// Generated by Github Copilot :)
		const version = 0;
		const visibility = 0; 
		const deviceType = App.deviceType; 
		const reserved = 0; 
		const bitField = (version << 5) | (visibility << 4) | (deviceType << 1) | reserved;
	
		// 16„Éê„Ç§„Éà„ÅÆ„É©„É≥„ÉÄ„É†„Å™ÂÄ§„ÇíÁîüÊàê
		const randomBytes = new Uint8Array(16);
		for(let i = 0; i < 16; i++) {
			randomBytes[i] = Math.floor(Math.random() * 256);
		}
	
		// „É¶„Éº„Ç∂„Éº„ÅåË¶ã„Çã„Åì„Å®„Åå„Åß„Åç„Çã„Éá„Éê„Ç§„ÇπÂêç„ÇíUTF-8„Åß„Ç®„É≥„Ç≥„Éº„Éâ„Åó„ÄÅ„Åù„ÅÆÈï∑„ÅïÔºà1„Éê„Ç§„ÉàÔºâ„Çí„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„Å®„Åó„Å¶ËøΩÂä†
		let nameChars = new TextEncoder().encode("Nearby Share Development Device");
		if(nameChars.length > 255) {
			nameChars = nameChars.slice(0, 255);
		}
		const nameLength = nameChars.length;
	
		// „Åô„Åπ„Å¶„Çí1„Å§„ÅÆUint8Array„Å´ÁµêÂêà
		const EndpointInfo = new Uint8Array(1 + 16 + 1 + nameChars.length);
		EndpointInfo[0] = bitField;
		EndpointInfo.set(randomBytes, 1);
		EndpointInfo[17] = nameLength;
		EndpointInfo.set(nameChars, 18);
	
		return EndpointInfo;
	}

	


// #endregion

// #region Component Mount
	/**
	 * React„ÅÆÈñ¢Êï∞
	 * „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Åå„Éû„Ç¶„É≥„Éà„Åï„Çå„Åü„Å®„Åç„Å´Áô∫ÁÅ´„Åô„Çã
	 */
	componentDidMount() {
		// #region mDNS Configuration
		/* HTTP„Çµ„Éº„Éê„Éº„ÇíËµ∑Âãï„ÄÄ*/
		this.__BridgeServer = this.httpServer();
		/* „Éá„Éº„Çø„ÇíÂàùÊúü„Éï„Çß„ÉÉ„ÉÅ */
		this.refreshData()

		/**
		 * mDNS„ÅÆTXT„É¨„Ç≥„Éº„Éâ
		 */
		const textRecode = App.TXTRecodeValue()

		/* mDNS„Çµ„Éº„Éì„Çπ„ÇíÈñãÂßã */
		zeroconf.publishService(
			/* „Çµ„Éº„Éì„ÇπÂêç */
			'FC9F5ED42C8A',
			/* „Éó„É≠„Éà„Ç≥„É´ */
			'tcp',
			/* „Éâ„É°„Ç§„É≥ */
			'local.',
			/* „Éõ„Çπ„ÉàÂêç */
			Buffer.from( textRecode ).toString('base64'),
			/* ‰ΩøÁî®„Éù„Éº„Éà */
			5353,
			/* TXT„É¨„Ç≥„Éº„Éâ */
			{
				n: Buffer.from(textRecode).toString('base64'),
			}
		)

		console.log(
			`EndpointInfo: ${Buffer.from(textRecode).toString("base64")}`
		)

		//#endregion
		// #region mDNS Event Handlers

		/* mDNS„ÅÆ„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É© */
		zeroconf.on('start', () => {
			this.context.setObjectState({ isScanning: true })
			this.context.logs.push({
				emoji: 'üîç',
				message: 'Started scanning and lunching the mDNS service...'
			})

		})

		zeroconf.on('stop', () => {
			this.context.setObjectState({ isScanning: false })
			this.context.logs.push({
				emoji: 'üõë',
				message: 'Stopped scanning'
			})
		})

		zeroconf.on('update', () => {
			this.context.logs.push({
				emoji: 'üîÑ',
				message: 'Updating Data...'
			})
		})

		zeroconf.on('resolved', async service => {
			this.context.logs.push({
				emoji: 'üêâ',
				message: `Resolved ${service.name} (${service.host})`
			})
			this.context.logs.push({
				emoji: 'üîó',
				message: JSON.stringify(service)
			})

			const deviceName = await this.getDeviceName(service)
			if (deviceName !== null) {
				this.context.logs.push({
					emoji: 'üì±',
					message: `Fetch Success: ${JSON.stringify(deviceName.data.clientId)} -  ${deviceName.data.clientName} (${deviceName.data.clientModel})`
				})
			}

			const newService = Object.assign( service, deviceName !== null ? deviceName.data : {}) as Service & { clientName : string, clientModel : string }

			this.context.setObjectState({
				services: {
					...this.context.services,
					[service.host]: newService,
				},
			})
		})


		zeroconf.on('error', err => {
			this.context.setObjectState({ isScanning: false })
			this.context.logs.push({
				emoji: 'üö®',
				message: `Error: ${err}`
			})
		})
	}

	//#endregion
	/**
	 * 
	 * „Éá„Éê„Ç§„ÇπÂêç„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞„ÄÇservice„ÇíÂºïÊï∞„Å´Âèñ„Çä„ÄÅPromise„ÇíËøî„Åó„Åæ„Åô„ÄÇ
	 * 
	 * @param {Service} service - „Çµ„Éº„Éì„ÇπÊÉÖÂ†±
	 */
	async getDeviceName( service : Service ) {
		const response = await fetch(`http://${service.host}:${this.AIRDROP_HTTP_PORT}/info`)
		if( response.ok ) {
			const data = await response.json() as { status : string, data : { clientId : string, clientName : string, clientModel : string } };
			return data;
		}

		return null;
	}

	/**
	 * React„ÅÆÈñ¢Êï∞
	 * „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„Åå„Ç¢„É≥„Éû„Ç¶„É≥„Éà„Åï„Çå„Åü„Å®„Åç„Å´Áô∫ÁÅ´„Åô„Çã
	 */
	componentWillUnmount() {
		this.context.logs.push({
			emoji: 'üõë',
			message: 'Unmounting the component and stopping the mDNS service...'
		})

		this.__BridgeServer !== null && this.__BridgeServer.stop()
		zeroconf.stop();
	}

	//#region Components 
	//#region Render

	/**
	 * „Éá„Éê„Ç§„Çπ‰∏ÄË¶ß„ÅÆ„É¨„É≥„ÉÄ„Éº
	 */
	renderRow = ({ item, index }: { item: string, index: number }) => {
		const { name, fullName, host, addresses, clientModel, clientName } = this.context.services[item]

		return (
			<TouchableOpacity
				onPress={() => {
					this.context.setObjectState({
						selectedService: host,
					});
                    this.props.navigation.navigate('DetailScreen');
                }}
				style={styles.textWithIcon}
			>
				<Icon name="smartphone" size={35} />
				<ListItem.Content>
					<ListItem.Title>{clientName}</ListItem.Title>
					<ListItem.Subtitle>{fullName} / {addresses.join(',')}</ListItem.Subtitle>
				</ListItem.Content>
			</TouchableOpacity>
		)
	}

	// #endregion

	refreshData = () => {
		const { isScanning } = this.context
		if (isScanning) {
			return
		}
		this.context.setObjectState({ services: {} })

		zeroconf.scan('FC9F5ED42C8A', 'tcp', undefined)
		this.context.logs.push({
			emoji: 'üîç‚ôªÔ∏è',
			message: 'ReScanning for services...'
		})

		clearTimeout(this.timeout)
		this.timeout = setTimeout(() => {
			zeroconf.stop()
		}, 5000)
	}

	render() {
		const { services, selectedService, isScanning } = this.context
		console.log(selectedService)

		return (
			<SafeAreaProvider>
				<SafeAreaView style={styles.container}>
					{
						isScanning ? (
							<>
								<View style={styles.textWithIcon}>
									<ActivityIndicator size="small" />
									<Text>‰ªòËøë„ÅÆ„Éá„Éê„Ç§„Çπ„ÇíÊ§úÁ¥¢‰∏≠</Text>
								</View>
							</>
						) : (
							<>
								<FlatList
									data={Object.keys(services)}
									renderItem={this.renderRow}
									keyExtractor={key => key}
									refreshControl={
										<RefreshControl
											refreshing={isScanning}
											onRefresh={this.refreshData}
											tintColor="skyblue"
										/>
									}
								/>
								<PaperButton icon="archive" mode='contained-tonal' onPress={() => this.props.navigation.navigate('LogScreen')}>
									„Éá„Éê„ÉÉ„ÇØ„É≠„Ç∞„ÇíÁ¢∫Ë™ç„Åô„Çã
								</PaperButton>
							</>
						)
					}
				</SafeAreaView>
			</SafeAreaProvider>
		)
	}

	//#endregion
}

//#region Styles

const styles = StyleSheet.create({
	udpadding: {
		paddingTop: 10,
		paddingBottom: 10
	},
	textWithIcon: {
		display: 'flex',
		flexDirection: 'row',
		alignContent: 'center',
		alignItems: 'center',
		textAlign: 'center',
		justifyContent: 'center',
		gap: 10,
		fontSize: 30
	},
	textWithIconSizeFree: {
		padding: 10,
		display: 'flex',
		flexDirection: 'row',
		alignContent: 'center',
		alignItems: 'center',
		textAlign: 'center',
		justifyContent: 'center',
		gap: 10,
	},
	container: {
		flex: 1,
        marginTop: 10,
		marginLeft: 10,
		marginRight: 10,
		marginBottom: 10,
	},
	closeButton: {
		padding: 20,
		textAlign: 'center',
	},
	json: {
		padding: 6,
		fontWeight: "bold",
		fontSize: 15,
	},
	logs: {
		padding: 3,
		fontSize: 20,
		fontWeight: "semibold"
	},
	state: {
		fontSize: 20,
		textAlign: 'center',
		margin: 30,
	},
	flexLog: {
		display: 'flex',
		flexDirection: "row",
		alignContent: "center"
	}
})

App.contextType = Context

//#endregion