import React, { Component } from 'react'
import {
	Platform,
	StyleSheet,
	TouchableOpacity,
	Text,
	FlatList,
	RefreshControl,
	View,
	TextBase,
	ScrollView as RNScrollView,
} from 'react-native'
import { SafeAreaProvider } from 'react-native-safe-area-context';
import SafeAreaView from 'react-native-safe-area-view';
import { Icon, ListItem } from 'react-native-elements'
import Zeroconf, { Service } from 'react-native-zeroconf'
import { BridgeServer } from 'react-native-http-bridge-refurbished';
import * as ImagePicker from 'react-native-image-picker';
import { 
	ActivityIndicator, 
	Text as PaperText, 
	Button as PaperButton 
} from 'react-native-paper';

import { Buffer } from 'buffer';

import { Ask } from './types/airdrop.ask';
import { ApplicationBar } from './components/application_bar';
import { AutoHeightImage } from './components/autosizedImage';
import { StaticBufferValues } from './components/staticBufferValues';
import { Discover } from './types/airdrop.discover';
//@ts-ignore

const zeroconf = new Zeroconf()

interface State {
	isScanning: boolean
	selectedService: string | null
	services: { [key: string]: Service }
	logs: {
		emoji: string,
		message: string
	}[],
	showLogs: boolean,
	image: string | null,
	senderData: Ask | null,
	notification: Notification | null
	showsDetailDisplay : boolean 
}

interface Notification {
	emoji: string,
	message: string
}

/**
 * ã‚¢ãƒ—ãƒªã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
 */
export default class App extends Component {

	/**
	 * ã‚¹ãƒ†ãƒ¼ãƒˆç®¡ç†	
	 */
	public state: State = {
		isScanning: false,
		selectedService: null,
		services: {} as { [key: string]: Service },
		logs: [],
		showLogs: false,
		image: null,
		senderData: {} as Ask,
		notification: {} as Notification,
		showsDetailDisplay : false
	}

	/**
	 * Zeroconfã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ãƒãƒ³ãƒ‰ãƒ©å¤‰æ•°	
	 */
	public timeout: NodeJS.Timeout | undefined = void 0

	/**
	 * ä½¿ç”¨ã™ã‚‹ãƒãƒ¼ãƒˆ
	 */
	public AIRDROP_HTTP_PORT = 8771

	/**
	 * HTTPã‚µãƒ¼ãƒãƒ¼ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	 */
	private __BridgeServer: BridgeServer | null = null

	/**
	 * HTTPã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ã—ã¾ã™ã€‚
	 * 
	 * @returns 
	 */
	public httpServer() {
		const httpbridge = new BridgeServer("neardrop.local", true)
		httpbridge.listen(this.AIRDROP_HTTP_PORT);

		this.state.logs.push({
			emoji: 'ğŸ”—',
			message: `Starting HTTP server on port ${this.AIRDROP_HTTP_PORT}`
		})

		httpbridge.get('/info', async ( request, response ) => {
			return ({
				status : "OK",
				data : {
					clientName : "Nearby Share Development Device",
					clientModel : Platform.OS
				}
			})
		})

		httpbridge.post("/Discover", async (request, response) => {
			return {
				"ReceiverMediaCapabilities": Buffer.from(JSON.stringify({
					version: 1
				})),
				"ReciverComputerName": "Google Pixel 6a",
				"ReceiverModelName": "Pixel 6a",
			} as Discover
		})

		httpbridge.post<Ask>("/Ask", async (request, response) => {

			const data = request.data
			this.state.senderData = data as Ask

			return {
				"ReceiverComputerName": "Google Pixel 6a",
				"ReceiverModelName": "Pixel 6a"
			} as Ask
		})

		httpbridge.post("/Upload", async (request, response) => {
			const data = request.data
			this.state.logs.push({
				emoji: 'ğŸ“¨',
				message: `Received ${data.byteLength} bytes of data`
			})

			this.state.notification = {
				emoji: 'ğŸ“¨',
				message: `Received ${data.byteLength} bytes of data`
			}

			return {
				"status": "OK"
			}
		})

		return httpbridge;
	}

	/**
	 * ãƒ‡ãƒã‚¤ã‚¹ã®ç¨®é¡ã‚’å–å¾—ã—ã¾ã™ã€‚
	 * ä¾å­˜ã—ãªã„staticãªé–¢æ•°
	 */
	static get deviceType() : number {
		const device = Platform.OS;
		switch( device ) {
			case "android" : return 1;
			case "ios" : return 1;
			case "macos" : return 3;
			case "windows" : return 3;
			case "web" : return 0;
			default: return 0;
		}
	}

	/**
	 * TXTãƒ¬ã‚³ãƒ¼ãƒ‰ã®å€¤ã‚’ç”Ÿæˆã—ã¾ã™ã€‚ 
	 */
	static TXTRecodeValue() : Uint8Array {
		// Generated by Github Copilot :)
		const version = 0;
		const visibility = 0; 
		const deviceType = App.deviceType; 
		const reserved = 0; 
		const bitField = (version << 5) | (visibility << 4) | (deviceType << 1) | reserved;
	
		// 16ãƒã‚¤ãƒˆã®ãƒ©ãƒ³ãƒ€ãƒ ãªå€¤ã‚’ç”Ÿæˆ
		const randomBytes = new Uint8Array(16);
		for(let i = 0; i < 16; i++) {
			randomBytes[i] = Math.floor(Math.random() * 256);
		}
	
		// ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã‚‹ã“ã¨ãŒã§ãã‚‹ãƒ‡ãƒã‚¤ã‚¹åã‚’UTF-8ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã€ãã®é•·ã•ï¼ˆ1ãƒã‚¤ãƒˆï¼‰ã‚’ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã¨ã—ã¦è¿½åŠ 
		let nameChars = new TextEncoder().encode("Nearby Share Development Device");
		if(nameChars.length > 255) {
			nameChars = nameChars.slice(0, 255);
		}
		const nameLength = nameChars.length;
	
		// ã™ã¹ã¦ã‚’1ã¤ã®Uint8Arrayã«çµåˆ
		const EndpointInfo = new Uint8Array(1 + 16 + 1 + nameChars.length);
		EndpointInfo[0] = bitField;
		EndpointInfo.set(randomBytes, 1);
		EndpointInfo[17] = nameLength;
		EndpointInfo.set(nameChars, 18);
	
		return EndpointInfo;
	}

	/**
	 * @deprecated OMGä½¿ã£ã¦ãªã„
	 * ã„ã‚‰ãªã„
	 */
	static getDeviceBitfield( field : number ){
		const version = field >> 5;
		const visibility = (field >> 4) & 1;
		const deviceType = (field >> 1) & 7;
		const reserved = field & 1;
		return {
			version,
			visibility,
			deviceType,
			reserved,
			bitField: (version << 5) | (visibility << 4) | (deviceType << 1) | reserved
		}
	}

	/**
	 * Reactã®é–¢æ•°
	 * ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒãƒã‚¦ãƒ³ãƒˆã•ã‚ŒãŸã¨ãã«ç™ºç«ã™ã‚‹
	 */
	componentDidMount() {
		/* HTTPã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ã€€*/
		this.__BridgeServer = this.httpServer();
		/* ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸãƒ•ã‚§ãƒƒãƒ */
		this.refreshData()

		/**
		 * mDNSã®TXTãƒ¬ã‚³ãƒ¼ãƒ‰
		 */
		const textRecode = App.TXTRecodeValue()

		/* mDNSã‚µãƒ¼ãƒ“ã‚¹ã‚’é–‹å§‹ */
		zeroconf.publishService(
			/* ã‚µãƒ¼ãƒ“ã‚¹å */
			'FC9F5ED42C8A',
			/* ãƒ—ãƒ­ãƒˆã‚³ãƒ« */
			'tcp',
			/* ãƒ‰ãƒ¡ã‚¤ãƒ³ */
			'local.',
			/* ãƒ›ã‚¹ãƒˆå */
			Buffer.from( textRecode ).toString('base64'),
			/* ä½¿ç”¨ãƒãƒ¼ãƒˆ */
			5353,
			/* TXTãƒ¬ã‚³ãƒ¼ãƒ‰ */
			{
				n: Buffer.from(textRecode).toString('base64'),
			}
		)

		console.log(
			`EndpointInfo: ${Buffer.from(textRecode).toString("base64")}`
		)

		/* mDNSã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ© */
		zeroconf.on('start', () => {
			this.setState({ isScanning: true })
			this.state.logs.push({
				emoji: 'ğŸ”',
				message: 'Started scanning and lunching the mDNS service...'
			})

		})

		zeroconf.on('stop', () => {
			this.setState({ isScanning: false })
			this.state.logs.push({
				emoji: 'ğŸ›‘',
				message: 'Stopped scanning'
			})
		})

		zeroconf.on('update', () => {
			this.state.logs.push({
				emoji: 'ğŸ”„',
				message: 'Updating Data...'
			})
		})

		zeroconf.on('resolved', async service => {
			this.state.logs.push({
				emoji: 'ğŸ‰',
				message: `Resolved ${service.name} (${service.host})`
			})
			this.state.logs.push({
				emoji: 'ğŸ”—',
				message: JSON.stringify(service)
			})

			const deviceName = await this.getDeviceName(service)
			if (deviceName !== null) {
				this.state.logs.push({
					emoji: 'ğŸ“±',
					message: `Device Name: ${deviceName.data.clientName} (${deviceName.data.clientModel})`
				})
			}

			this.setState({
				services: {
					...this.state.services,
					[service.host]: service,
				},
			})
		})


		zeroconf.on('error', err => {
			this.setState({ isScanning: false })
			this.state.logs.push({
				emoji: 'ğŸš¨',
				message: `Error: ${err}`
			})
		})
	}

	/**
	 * 
	 * ãƒ‡ãƒã‚¤ã‚¹åã‚’å–å¾—ã™ã‚‹é–¢æ•°ã€‚serviceã‚’å¼•æ•°ã«å–ã‚Šã€Promiseã‚’è¿”ã—ã¾ã™ã€‚
	 * 
	 * @param {Service} service - ã‚µãƒ¼ãƒ“ã‚¹æƒ…å ±
	 */
	async getDeviceName( service : Service ) {
		const response = await fetch(`http://${service.host}:${this.AIRDROP_HTTP_PORT}/info`)
		if( response.ok ) {
			const data = await response.json() as { status : string, data : { clientName : string, clientModel : string } };
			return data;
		}

		return null;
	}

	/**
	 * Reactã®é–¢æ•°
	 * ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒã‚¢ãƒ³ãƒã‚¦ãƒ³ãƒˆã•ã‚ŒãŸã¨ãã«ç™ºç«ã™ã‚‹
	 */
	componentWillUnmount() {

		this.state.logs.push({
			emoji: 'ğŸ›‘',
			message: 'Unmounting the component and stopping the mDNS service...'
		})

		this.__BridgeServer !== null && this.__BridgeServer.stop()
		zeroconf.stop();
	}

	/**
	 * ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–¢æ•°
	 */
	renderRow = ({ item, index }: { item: string, index: number }) => {
		const { name, fullName, host, addresses } = this.state.services[item]

		return (
			<TouchableOpacity
				onPress={() =>
					this.setState({
						selectedService: host,
					})}
				style={styles.textWithIcon}
			>
				<Icon name="smartphone" size={35} />
				<ListItem.Content>
					<ListItem.Title>{host}</ListItem.Title>
					<ListItem.Subtitle>{fullName} / {addresses.join(',')}</ListItem.Subtitle>
				</ListItem.Content>
			</TouchableOpacity>
		)
	}

	refreshData = () => {
		const { isScanning } = this.state
		if (isScanning) {
			return
		}
		this.setState({ services: [] })

		zeroconf.scan('FC9F5ED42C8A', 'tcp', undefined)
		this.state.logs.push({
			emoji: 'ğŸ”â™»ï¸',
			message: 'ReScanning for services...'
		})

		clearTimeout(this.timeout)
		this.timeout = setTimeout(() => {
			zeroconf.stop()
		}, 5000)
	}

	showlogs = () => {
		this.setState({ selectedService: null })
		this.setState({ showLogs: true })
	}

	imagePicker = () => {
		const option: ImagePicker.ImageLibraryOptions = {
			mediaType: 'photo',
			quality: 1,
			includeBase64: true
		}

		ImagePicker.launchImageLibrary(option, (resposeImage) => {
			if (resposeImage.didCancel) {
				this.state.logs.push({
					emoji: '[!]',
					message: `User cancelled the image picker`
				})
			}
			else if (resposeImage.errorMessage || resposeImage.errorCode) {
				this.state.logs.push({
					emoji: '[!]',
					message: `Image picker error: ${resposeImage.errorCode || resposeImage.errorMessage}`
				})
			}
			else {
				if (resposeImage.assets === null || resposeImage.assets?.length === 0) return;
				if (!Array.isArray(resposeImage.assets)) return;
				if (typeof resposeImage.assets[0].base64 === "undefined") return;
				this.state.logs.push({
					emoji: 'ğŸ“¸',
					message: `Image selected: ${JSON.stringify(resposeImage.assets[0].originalPath)}`
				})
				this.setState({ image: resposeImage.assets[0].uri })
			}
		})
	}

	sendImage = async (service: Service) => {
		if (this.state.senderData === null) return;
		if (this.state.image === null) return;

		//const { senderData } = this.state;

		const imageRes = await fetch(this.state.image);
		this.state.logs.push({
			emoji: 'ğŸ“¡',
			message: `Fetching Image : ${this.state.image}`
		})
		const imageBlob = await imageRes.arrayBuffer();
		this.state.logs.push({
			emoji: 'ğŸ“¡',
			message: `Fetched Image : ${imageBlob.byteLength} bytes from ${this.state.image}`
		})

		const imageBuff = Buffer.from(
			imageBlob
		);

		this.state.logs.push({
			emoji: 'ğŸ’ ',
			message: `Buffered Image : ${imageBuff.byteLength} bytes `
		})

		this.state.logs.push({
			emoji: 'ğŸ“¡',
			message: `POST http://${service.host}:${this.AIRDROP_HTTP_PORT}/Ask`
		})



		const response = await fetch(`http://${service.host}:${this.AIRDROP_HTTP_PORT}/Ask`, {
			method: "POST",
			headers: {
				"Content-Type": "application/json"
			},
			body: JSON.stringify({
				"image": this.state.image,
				"senderData": this.state.senderData
			})
		}).catch((err) => {
			this.state.logs.push({
				emoji: 'ğŸš¨',
				message: `Authorization not granted by ${service.fullName}(${service.addresses[0]}) successfully`
			})
		})

		if (response === undefined) return;

		if (response.ok) {
			this.state.logs.push({
				emoji: 'âœ¨',
				message: `Authorization granted by ${service.host}(${service.addresses[0]}) successfully`
			})

			await fetch(`http://${service.host}:${this.AIRDROP_HTTP_PORT}/Upload`, {
				method: "POST",
				headers: {
					"Content-Type": "application/x-cpio",
					"Transfer-Encoding": "chunked",
					"Content-Length": "0",
					"Connection": "close"
				},
				body: imageBuff.toString()
			})

			this.state.logs.push({
				emoji: 'ğŸ“¨',
				message: `Image sent to ${service.host} successfully`
			})
		} else {
			this.state.logs.push({
				emoji: 'ğŸš¨',
				message: `This is not a valid AirDrop service: ${service.host}`
			})
		}
	}

	static getTextRecodeValue( buffer : Uint8Array ) {
		console.log(
			buffer
		)
		const version = buffer[0] >> 5;
		const visibility = (buffer[0] >> 4) & 1;
		const deviceType = (buffer[0] >> 1) & 7;
		const reserved = buffer[0] & 1;
		const bitField = (version << 5) | (visibility << 4) | (deviceType << 1) | reserved;
		const randomBytes = buffer.slice(1, 17);
		const nameLength = buffer[17];
		const nameChars = buffer.slice(18, 18 + nameLength);

		return {
			version,
			visibility,
			deviceType,
			reserved,
			bitField,
			randomBytes,
			nameLength,
			nameChars
		}
	
	}

	render() {
		const { services, selectedService, isScanning } = this.state
		console.log(selectedService)

		const service = selectedService ? services[selectedService] : null;

		if( this.state.showsDetailDisplay && service ) {
			return (
				<SafeAreaProvider>
					<SafeAreaView style={styles.container}>
						<ApplicationBar 
							closeMenuFunction={() => this.setState({ selectedService: null })} 
							customTitle='ãƒ‡ãƒã‚¤ã‚¹ã®è©³ç´°æƒ…å ±'  
							detailMenuFunction={() => this.setState({ showsDetailDisplay: false })}
						/>
						<RNScrollView>
							<View style={styles.udpadding}>
								<PaperText variant="headlineMedium" >
									{service.host.replace('-', " ")} ({service.addresses.join(', ')})
								</PaperText>
								<PaperText>
									{service.txt.n}
								</PaperText>
								<PaperText>
									ãƒ†ã‚­ã‚¹ãƒˆãƒ¬ã‚³ãƒ¼ãƒ‰ãƒãƒƒãƒ•ã‚¡ãƒ¼ : {JSON.stringify(App.getTextRecodeValue(new Uint8Array(Buffer.from(service.txt.n))))}
								</PaperText>
								<PaperText>
									ãƒ›ã‚¹ãƒˆå : {service.host}
								</PaperText>
								<PaperText>
									ã‚¢ãƒ‰ãƒ¬ã‚¹ : {service.addresses.join(', ')}
								</PaperText>
								<PaperText>
									ãƒ•ãƒ«ãƒãƒ¼ãƒ  : {service.fullName}
								</PaperText>
								<PaperText>
									ãƒãƒ¼ãƒˆ : {service.port}
								</PaperText>
								<PaperText>
									åå‰ãƒãƒƒãƒ•ã‚¡ãƒ¼ : {Buffer.from(service.name).toString("hex")}
								</PaperText>
								<PaperText>
									DeviceType : { App.getTextRecodeValue(new Uint8Array(Buffer.from(service.txt.n))).deviceType }
								</PaperText>
								<PaperText> 
									nubejson : { new Uint8Array( Buffer.from( service.txt.n ) )[0] }
								</PaperText>
							</View>
						</RNScrollView>
					</SafeAreaView>
				</SafeAreaProvider>
			)
		}

		if (service) {
			return (
				<SafeAreaProvider>
					<SafeAreaView style={styles.container}>
						<ApplicationBar 
							closeMenuFunction={() => this.setState({ selectedService: null })} 
							customTitle='ãƒ‡ãƒã‚¤ã‚¹ã®è©³ç´°' 
							detailMenuFunction={() => this.setState({ showsDetailDisplay: true })}
						/>
						<RNScrollView>
							<View style={styles.udpadding}>
								<PaperText variant="headlineMedium" >
									{service.host.replace('-', " ")} ({service.addresses.join(', ')})
								</PaperText>
								<PaperText>
									æ­£å¸¸ã«èªè­˜ã•ã‚Œã¦ã„ã¾ã™ã€‚
								</PaperText>
							</View>
							<PaperButton mode="contained-tonal" onPress={this.imagePicker}>
								ç”»åƒã‚’é¸æŠã™ã‚‹
							</PaperButton>
							<View style={styles.udpadding}>
								{this.state.image && <AutoHeightImage source={{ uri: this.state.image }} width={350} />}
							</View>
							{this.state.image && <PaperButton mode="contained-tonal" onPress={() => this.sendImage(service)}>é€ä¿¡ã™ã‚‹</PaperButton>}
						</RNScrollView>
					</SafeAreaView>
				</SafeAreaProvider>
			)
		}

		if (this.state.showLogs) {
			return (
				<SafeAreaProvider>
					<SafeAreaView style={styles.container}>
						<ApplicationBar closeMenuFunction={() => this.setState({ showLogs: false })} customTitle='ãƒ‡ãƒãƒƒã‚¯ãƒ­ã‚°' />
						<RNScrollView style={styles.logs} >
							{this.state.logs.map((log, index) => (
								<View style={styles.flexLog} key={"v" + index}>
									<Text key={index} style={styles.logs}>{log.emoji}</Text>
									<Text key={"k" + index} style={styles.json}>{log.message}</Text>
								</View>
							))}
							<PaperButton icon="delete" mode='contained-tonal' onPress={() => this.setState({ logs: [] })}>
								ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹
							</PaperButton>
						</RNScrollView>
					</SafeAreaView>
				</SafeAreaProvider>
			)
		}

		return (
			<SafeAreaProvider>
				<SafeAreaView style={styles.container}>
					<ApplicationBar />
					{
						isScanning ? (
							<>
								<View style={styles.textWithIcon}>
									<ActivityIndicator size="small" />
									<Text>ä»˜è¿‘ã®ãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œç´¢ä¸­</Text>
								</View>
							</>
						) : (
							<>
								<FlatList
									data={Object.keys(services)}
									renderItem={this.renderRow}
									keyExtractor={key => key}
									refreshControl={
										<RefreshControl
											refreshing={isScanning}
											onRefresh={this.refreshData}
											tintColor="skyblue"
										/>
									}
								/>
								<PaperButton icon="archive" mode='contained-tonal' onPress={this.showlogs}>
									ãƒ‡ãƒãƒƒã‚¯ãƒ­ã‚°ã‚’ç¢ºèªã™ã‚‹
								</PaperButton>
							</>
						)
					}
				</SafeAreaView>
			</SafeAreaProvider>
		)
	}
}

const styles = StyleSheet.create({
	udpadding: {
		paddingTop: 10,
		paddingBottom: 10
	},
	textWithIcon: {
		display: 'flex',
		flexDirection: 'row',
		alignContent: 'center',
		alignItems: 'center',
		textAlign: 'center',
		justifyContent: 'center',
		gap: 10,
		fontSize: 30
	},
	textWithIconSizeFree: {
		padding: 10,
		display: 'flex',
		flexDirection: 'row',
		alignContent: 'center',
		alignItems: 'center',
		textAlign: 'center',
		justifyContent: 'center',
		gap: 10,
	},
	container: {
		flex: 1,
		marginLeft: 10,
		marginRight: 10,
		marginBottom: 10,
	},
	closeButton: {
		padding: 20,
		textAlign: 'center',
	},
	json: {
		padding: 6,
		fontWeight: "bold",
		fontSize: 15,
	},
	logs: {
		padding: 3,
		fontSize: 20,
		fontWeight: "semibold"
	},
	state: {
		fontSize: 20,
		textAlign: 'center',
		margin: 30,
	},
	flexLog: {
		display: 'flex',
		flexDirection: "row",
		alignContent: "center"
	}
})